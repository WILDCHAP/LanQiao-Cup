/*首先，很容易发现多边形顶点数就是n，而且边数也是n。又因为多边形的边都平行于坐标轴，
所以L至少为4且必须是偶数。要使多边形为星型多边形，则这个多边形必须存在核。
这个题里。多边形的内角只有90°和270°，所以显然可以发现，如果存在两个相邻的内角均为270°，
则这个多边形是不存在核的。也就是说，角度序列里不能有两个O相邻，而且头尾也不能同时是O。
然后我们确定R和O的个数。N边形的内角和为(N - 2)*180，而R代表的内角为90，O代表的为270，
所以很容易算出R和O的数量，分别为(n + 4)/2个和(n - 4)/2个。于是问题转化为，
在n个位置上放置(n - 4)/2个O且任意两个不相邻有多少种放法。*/
#include<iostream>
using namespace std;
int way=0;
void f(int L,int n,int x,int beg)		//L个放n个O,前一个为x(2为首个),beg 
{
	if(n<0 || n>L)return;
	if(!L||!n)			//终点
	{
		way++;return;
	} 
	if(L==1&&n==1)	//最后一个位置放270
	{
		if(beg && x)		//只有开头是90才能 
		way++;
		return;
	}
	if(x==2)		//首个
	{
		f(L-1,n-1,0,0);	//L-1个位置放n-1个O,前一个为O，开头的为O
		f(L-1,n,1,1);	 //L-1个位置放n个O,前一个为R，开头的为R
	} 
	else
	{
		if(x==1)
		f(L-1,n-1,0,beg);	//前一个为90，则可以放90和270 
		f(L-1,n,1,beg);
	}
} 

int main()
{
	int a[100],k=0,n,i;		//存放命令L，提交改1000
	cin>>n;
	while(n) 
	{
		a[k++]=n;
		cin>>n;
	}
	for(i=0;i<k;i++)
	{
		way=0;
		if(a[i]%2==0&&a[i]>=4)
		{
			f(a[i],a[i]/2-2,2,2);
		} 
		cout<<"Case "<<a[i]<<": "<<way<<endl;
	}
	return 0;
} 
